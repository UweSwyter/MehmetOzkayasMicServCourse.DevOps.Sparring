Basic docker commands:

  docker [ENTER] => lists all docker commands

  docker login => asks for your docker login credentials, so you can push your images to hub.docker.com, for example

  Image-related commands:
    docker images => lists all images in the computer
    docker images -q => lists all images in the computer - displays image's ids only

    docker pull [image name]:[tag name] => pulls/downloads images from the docker registry (hub.docker.com | azure container registry)

    docker rmi [the image id] => removes some image by informing its id
    docker rmi [the image id] -f => removes all the images by informing its id (there may many images with different tags)
    docker rmi $(docker images -q) => removes all images available at the local machine

    docker build -t [a name of your choice] . => builds the image by using the local dockerfile
    NOTE: the period indicates that the dockerfile is in this very path you're trying to run this command in!

    docker build -f "E:\Codebase\_.NET Solutions\Core\5.x\MehmetOzkayasMicServCourse.DevOps\Shopping\src\Shopping.Client\Dockerfile" --force-rm -t [a name of your choice] "E:\Codebase\_.NET Solutions\Core\5.x\MehmetOzkayasMicServCourse.DevOps\Shopping"  => builds the image by using some specific dockerfile filepath
    NOTES:
        docker command generated by visual studio without some extra arguments (label, for example)
        -f => filepath
        (I'M NOT SURE) -t => use this flag whenever you wish to push the image to some Docker container registry

    docker tag [the desired image id] [your docker registry repository name] => tags and associates the image with some repository in the container registry so you can push it
     -> example: docker tag 818 cristianomartinsdiasspbr1982/mehmet_ozkaya_devops_course_shoppingapp
    NOTES: after you have run this command successfully, execute 'docker images' and check for the newly created tagged image

    docker push [your username on docker hub, for example]/[your repository on docker hub, for example]:[a tagname of your choice] => pushes images to the docker registry (hub.docker.com | azure container registry)
     -> example: docker push cristianomartinsdiasspbr1982/mehmet_ozkaya_devops_course_shoppingapp:latest
     NOTES:
       - requires login on hub.docker.com => docker login [ENTER]
       - the image you wish to send must have a tag!
       - after you have run this command successfully, check for you newly pushed repository online at:
         https://hub.docker.com/repository/docker/cristianomartinsdiasspbr1982/mehmet_ozkaya_devops_course_shoppingapp/general

    docker pull [repository name]:[tag name] => pulls/downloads an image from the informed repository
     -> example: docker pull cristianomartinsdiasspbr1982/mehmet_ozkaya_devops_course_shoppingapp:latest
    NOTES:
       - the tag argument is optional

  Container-related commands:
    docker ps -a => lists all running containers
    docker ps -aq => lists all running containers - displays container's ids only

    docker stop [the container id] => stops the desired container by informing its id
    docker stop $(docker ps -aq) => stops running all containers with this single command

    docker rm [the container id] => removes the desired container by informing its id
    docker rm $(docker ps -aq) => removes all running containers
      NOTES: you may have to stop them first, unless you force it with the command down below
    docker rm $(docker ps -aq) --force => removes all running containers with no need to stop them first
    docker system prune => removes all unused containers, networks, images (both dangling and unreferenced), and optionally, volumes.

    docker run -d -p [EXTERNAL PORT : INTERNAL PORT] --name [a name of your choice for the container] [the correct image name]
    NOTES:
       -d => stands for detached mode, so you can still run other commands in the same prompt
       -p => you access the application by using the EXTERNAL PORT!

     -> example: spins up a docker container with mongodb
        docker run --name devopscourse_shoppingclient_mongodb -p 27017:27017 -e MONGO_INITDB_ROOT_USERNAME=admin_cris -e MONGO_INITDB_ROOT_PASSWORD=Secret!123 -d mongo
        -d => stands for detached mode, so you can still run other commands in the same prompt
        -p => you access the application by using the EXTERNAL PORT!
        -e => environment variable to be overriden by some other informed value

    docker logs -f [some container name] => displays log data for that running container
     -> example: docker logs -f devopscourse_shoppingclient_mongodb

    docker exec -it [some container name] [/some/folder/path] => starts an interactive terminal in the informed container's informed folder
     -> example: docker exec -it devopscourse_shoppingclient_mongodb /bin/bash

  Docker-compose-related commands:
    docker-compose -f docker-compose.yml -f docker-compose.override.yml up -d => spins up the docker composition
    docker-compose -f docker-compose.yml -f docker-compose.override.yml down => stops the docker composition
    docker-compose -f docker-compose.yml -f docker-compose.override.yml up --build => builds/rebuilds all composition's docker images

MONGODB BASH COMMAND EXAMPLES (after running "docker exec -it devopscourse_shoppingclient_mongodb /bin/bash" command)
Initial command => mongo [ENTER]
use test
db.auth('[the user name]') #then, you enter your password
show dbs [ENTER] | show databases [ENTER]
use ProductCatalog [ENTER] #this creates a new database and navigates to it
db.createCollection('Products') [ENTER]
db.Products.insertMany([{'Name' : 'Product 1', 'Description' : 'Product 1 description'}, {'Name' : 'Product N', 'Description' : 'Product N description'}])
db.Products.find({}).pretty()
db.Products.remove({})
show collections

TIP: Use VsCode IDE tool for K8s yaml file creation!
Kubernetes(k8s) commands:
kubectl get all
kubectl cluster-info
kubectl get nodes
kubectl get pods
kubectl get services
kubectl get replicasets
kubectl get deployments
kubectl get configMaps
kubectl get secrets
kubectl get hpa
kubectl delete deployment [the deployment name]
  note: this command cascade deletes its underlying replicasets and pods!
kubectl delete service [the service name]
kubectl run myapp --image=myrepo:mytag <<< IMPERATIVE WAY TO RUN IMAGES INSIDE K8S
  example: kubectl run local-nginx --image=nginx
kubectl apply -f app.yaml <<< DECLARATIVE WAY TO RUN IMAGES INSIDE K8S WITH YML MANIFESTS FILES
kubectl port-forward [app name] [EXTERNAL:INTERNAL port] <<< this command allows you to reach the running image locally [EXTERNAL:INTERNAL port]
  example: kubectl port-forward local-nginx 8080:80
kubectl delete pod [pod name]
kubectl create deployment [deployment name] --image=[image name]
kubectl edit deployment [deployment name] => the notepad program with the yaml file is opened. You can edit, save and close it. (Kubernetes will refresh the configuration automatically!)
kubectl get deployment [the deployment name] -o yaml => retrieves status information which k8s adds to the yaml file!

(Some useful troubleshooting commands)
kubectl logs [pod name]
kubectl describe pod [pod name] => displays an events list, besides many other details
kubectl exec [pod name] -it sh => starts and interactive shell on the desired pod

(You can use these querying commands after creating/applying your k8s elements, so to speak)
kubectl describe service [the service name] => retrieves more details about the service, like the EXTERNAL PORT (TargetPort) and Endpoints, for example!
kubectl get pod [the pod name] -o wide => retrieves more details about the specified pod, like the pod's dynamically assigned IP addresses, for example!
kubectl get pod -o wide => retrieves more details about all available pod, like the pods' dynamically assigned IP addresses, for example!

(Commands for working declaratively with k8s)
kubectl create -f [filename].yml
kubectl apply -f [filename].yml -> use it to create the deployents. Use it also after updating the file so k8s applies the changes (if any)
kubectl describe -f [filename].yml
kubectl delete -f [filename].yml

kubectl delete -f . -> deletes all the entire cluster setup by reading all yaml files located at the current folder
kubectl delete -f ./[folder name] -> deletes all the entire cluster setup by reading all yaml files located at the informed folder path

kubectl config get-contexts -> returns all configs in the local machine. Note that the asterisk marks the current config being used
kubectl config current-context -> returns the current context
kubectl config use-context [the context name] -> switches the current context

Commands for installing and accessing Kubernetes Web UI Dashboard:
1 - kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.4.0/aio/deploy/recommended.yaml
2 - kubectl describe secret -n kube-system (you will use a security token that is displayed at the bottom of the console)
3 - kubectl proxy
4 - In your browser, open the following link: http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/
5 - Copy the token that is displayed after performing step 2 then paste it into the token field which is made available when you opened the link above

Support url's:
https://github.com/kubernetes/dashboard
https://github.com/kubernetes/dashboard/blob/master/docs/user/access-control/creating-sample-user.md

(Commands Cheat sheet: https://kubernetes.io/docs/reference/kubectl/cheatsheet)

Azure CLI commands: (az utility tool) - Deploying the Microservices onto Azure, Azure Container Servicse and Azure Kubernetes Services
First things first: download and install Azure CLI (refer to: https://docs.microsoft.com/en-us/cli/azure/install-azure-cli)
  az --version
Second: you must login to Azure. Just provide your Azure credentials
  az login

HOW TO CREATE A AZURE KUBERNETES CLUSTER AND DEPLOY THE MICROSERVICES INTO IT

1 - Create a Resource Group:
az group create --name mehmetozkaya_devopscourse_resgroup --location brazilsouth

2 - Create an Azure Container Registry:
az acr create --resource-group mehmetozkaya_devopscourse_resgroup --name shoppingacr20220501 --sku Basic

3 - Enable the administrator account for deploying containers in the Azure Container Registry (ACR)
az acr update -n shoppingacr20220501 --admin-enabled true
When this command was executed, I checked out the Azure Portal on the web -> Access Keys section
and saw two created passwords:
Login server: shoppingacr20220501.azurecr.io
Username: shoppingacr20220501
Password: vOV8u4QFcFR3bQeSKzokRzUVz/+1NoLY
Password 2: Y5KAp8tomzhbVYZ4I+UxhkLW4rsy1TgK)

4 - Login to the Azure Container Registry (ACR)
az acr login --name shoppingacr20220501

5 - Retrieve AcrLoginServer information with the following command:
az acr list --resource-group mehmetozkaya_devopscourse_resgroup --query "[].{acrLoginServer:loginServer}" --output table

6 - Tag the docker images, so they can be registered in the Azure Container Registry (ACR).
Note that here you tag the container with the login server information, extracted from the step 5:
docker tag shoppingapi:latest shoppingacr20220501.azurecr.io/shoppingapi:v1
docker tag shoppingclient:latest shoppingacr20220501.azurecr.io/shoppingclient:v1
6.1 Check to see if the images were tagged accordingly:
    docker images
NOTES: And why v1 tag? You deliver continuously multiple versions of your containers! (v1,v2,vN...)

7 - Push the containers to the Azure Container Registry
Note that these pushed containers are not pushed to the Docker Hub!
docker push shoppingacr20220501.azurecr.io/shoppingapi:v1
docker push shoppingacr20220501.azurecr.io/shoppingclient:v1
7.1 Check to see if the containers' repositories were successfully:
    az acr repository list --name shoppingacr20220501 --output table
7.2 Also, check the containers repositories tags:
    az acr repository show-tags --name shoppingacr20220501 --repository shoppingapi --output table
    az acr repository show-tags --name shoppingacr20220501 --repository shoppingclient --output table

8 - Create a Azure Kubernetes Cluster
az aks create --resource-group mehmetozkaya_devopscourse_resgroup --name ShoppingAksCluster --node-count 1 --generate-ssh-keys --attach-acr shoppingacr20220501

9 - Install Azure AKS CLI so you can run kucebtl commands on the cloud's kubernetes clusters
az aks install-cli

10 - Connect to AKS Cluster. But, first, we need to get Azure AKS credentials in order to connect to it.
az aks get-credentials --resource-group mehmetozkaya_devopscourse_resgroup --name ShoppingAksCluster
(after executing this command, I received the following message: Merged "ShoppingAksCluster" as current context in C:\Users\TheOwner\.kube\config)
10.1 - To check you are in the 'ShoppingAksCluster' AKS cluster context, type the following commands:
       kubectl config current-context
       kubectl get nodes
10.2 - You can check and, if necessary, switch the context by right-clicking in the docker icon tray

11 - In order to AKS be able to pull the images from the ACR, create a ACR secret so it used by AKS to pull these images
kubectl create secret docker-registry acr-secret --docker-server=shoppingacr20220501.azurecr.io --docker-username=shoppingacr20220501 --docker-password=vOV8u4QFcFR3bQeSKzokRzUVz/+1NoLY --docker-email=rblackm@hotmail.com
NOTES:
--docker-server -> extracted from step 3
--docker-username -> extracted from step 3
--docker-password -> extracted from step 3
--docker-email -> my subscription account e-mail address
11.1 - Check the newly created secret with the following command:
    kubectl get secrets

12 - Copy the kubernetes .yaml manifest files located at your Shopping solution 'k8s' folder to 'aks' folder.
Next, update its docker image paths along with their tags according to the names that were used to push them (see step 7); have them use the Azure Container Services login server (identified by executing the step 5 instructions).
Lastly, but least, we must add the pull secret to all the deployment files. 
NOTE 1: The image repositories and the tags can be retrieved by executing steps 7.1 and 7.2
NOTE 2: Regarding to the pull secret, open shoppingclientapi.yaml file and search for 'imagePullSecrets:' declaration. In there, the name 'acr-secret' (created in step 11) was referenced

13 - In shoppingapi.yaml file, replace the entire service declaration with this one:
apiVersion: v1
kind: Service
metadata:
  #type: NodePort REMOVED!
  name: shoppingapi-service
spec:
  selector:
    app: shoppingapi
  ports:
    - protocol: TCP
      port: 80 #THIS WAS 8000
      #targetPort: 80 REMOVED!
      #nodePort: 31000 REMOVED!

14 - In shoppingapi-configmap.yaml file, replace the entire configmap declaration with this one:
apiVersion: v1
kind: ConfigMap
metadata:
  name: shoppingapi-configmap
data:
  shoppingapi_uri: http://shoppingapi-service #:8000 NO NEED TO INFORM PORT 8000

15 - In shoppingclient.yaml file, replace the entire service declaration with this one:
apiVersion: v1
kind: Service
metadata:
  name: shoppingclient-service
spec:
  type: LoadBalancer #WAS NodePort
  selector:
    app: shoppingclient
  ports:
    - protocol: TCP
      port: 80 #THIS WAS 8001
      #targetPort: 80 REMOVED!
      #nodePort: 30000 REMOVED!
NOTE: AKS will automatically create an Ingress IP for routing the requests. Yay!

16 - Check again that the context is pointed to yout AKS cluster
kubectl config get-contexts
kubectl config current-context

17 - Run kubectl apply to create the ASK cluster
kubectl apply -f ./aks/
17.1 Check to see if the resources were successfully created (troubleshooting purposes, in case anything goes sideways)
     kubectl get all
     kubectl get services (wait for the external IP address to be made available at the LoadBalancer type column)
     kubectl get pods
     kubectl describe pod shoppingclient-deployment-677d55bcf4-2ff7x <<< CHECK THE Events SECTION FOR ANY PROBLEM
17.2 Copy the external address to browser address bar and check to see if it's ok!

HOW TO PROGRAMATICALLY UPSCALE/DOWNSCALE THE PODS
kubectl scale --replicas=2 deployment.apps/shoppingclient-deployment

HOW TO DECLARATIVELY UPSCALE/DOWNSCALE THE PODS
1. Change the application deployment manifest' spec: -> replicas node
2. kubectl apply -f ./aks/

HOW TO CONFIGURE DECLARATIVELY AUTOSCALING IN AKS
1. Check AKS version to make sure it is greater than 1.1. If so, it's ok for autoscaling feature
   az aks show --resource-group mehmetozkaya_devopscourse_resgroup --name ShoppingAksCluster --query kubernetesVersion --output table

2. Check the manifest yaml file called shoppingautoscaling.yaml then apply the manifests:
   kubectl apply -f ./aks/
   NOTE: It may take a while to scale up/down the pods
2.1 Check to see if the auto scalers were successfully created (troubleshooting purposes, in case anything goes sideways)
   kubectl get pods
   kubectl describe pod shoppingclient-deployment-677d55bcf4-2ff7x <<< CHECK THE Events SECTION FOR ANY PROBLEM
   kubectl get hpa

HOW TO REDEPLOY THE CLUSTER FOR CHANGES

1.Change e recompile your codebase, ensuring sucess.
2.Rebuild the application image locally (docker-compose up, docker build...)
3.Tag the newly created image by using the Azure Container Registry login server (STEP 5). Assign a new version tag too (v2, v3, vN) -> SEE STEP 6
4.Login to Azure Container Registry -> SEE STEP 4
5.Push the newly created repository to the Azure Container Registry. Don't forget to change the tag version! -> SEE STEP 7
6.Open the application corresponding deplyments manifest yaml file and do the following changes:
  6.1 -> Update the 'image:' value to the new image name as per step 3
  6.2 -> Make sure 'replicas' value is at least the value of 2 so there is no downtime at all when kubernetes is replacing the old container for the new one
7.Query the service (Type = LoadBalancer) for the external IP address, then navigate to it:
  kubectl get services

HOW TO CLEAN UP AZURE RESOURCES
1. Run:
   kubectl delete -f ./aks/
2. Next, run: 
   kubectl get all
3. Next, run:
  az group delete --name mehmetozkaya_devopscourse_resgroup --yes --no-wait
4. Lastly, but not least
  Navigate to the Azure Portal then exclude all remaining resources manually as well